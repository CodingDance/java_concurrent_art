#第三章 Java内存模型

##一、基础

###1、并发的两个关键问题

线程间通信和线程间同步

线程通信机制：

    共享内存：隐式通信，显式同步
    
    消息传递：显式通信，隐式同步
    
Java的并发采用的是共享内存模型。
    
###2、java内存结构

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个
私有的本地内存，本地内存中存储了该线程读/写共享变量的副本。
>本地内存是JMM的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化

线程A与线程B之间要通信必须经过以下两个步骤：

    1、线程A把本地内存A中更新过的共享变量刷新到主内存中去
    2、线程B到主内存中去读取A之前已更新过的共享变量

JMM通过控制主内存与每个线程的本地内存之间的交互来为java程序员提供内存可见性保证

###3、指令重排序

源码--------》编译器优化重排序-------》指令级并行重排序----------》内存系统重排序---------》最终的指令序列

后面两个属于处理器的重排序

对于编译器，JMM的编译器会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则
会要求Java编译器在生成指令序列时，插入特定的内存屏障指令，从而禁止特定类型的处理器重排序。

###4、并发模型分类

四种内存屏障：

    LoadLoad：确保load1的数据先于laod2及后续所有load指令进行装载
    StoreStore：确保store1的数据对其他处理器的可见性先于store2及后续所有存储指令
    LoadStore：确保load装载先于store的存储刷新到内存
    StoreLoad：该屏障前的指令全部完成之后才会执行后面的指令（开销大）
    
###5、先行发生（happens-before）

JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

##二、重排序

数据依赖性

在单线程程序中，对存在控制依赖的操作重排序不会改变执行结果；但在多线程程序中，对存在控制
依赖的操作重排序，可能会改变程序的执行结果。

    详见30页的例子

##三、顺序一致性

##四、volatile内存语义


